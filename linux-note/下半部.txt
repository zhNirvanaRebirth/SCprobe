下半部就是执行与中断处理密切相关但中断处理程序本身不执行的工作

执行时间不确定，只是相对中断处理程序推迟了一些

下半部的实现：
1、BH(bottom half)机制:提供一个静态创建的、由32个bottom half组成的链表，上半部通过一个32位整数中的一位来标示执行哪一个bottom half
2、任务队列(task queue)机制：定义了一组队列，每个队列包含一个由等待调用的函数组成的链表
3、软中断(softirq)：静态定义的下半部接口，数量有32个，可以在所有处理器上同时执行（类型相同也可以）
4、tasklet：需要动态注册，两个不同类型的tasklet可以在不同的处理器上同时运行，但类型相同的不行
5、工作队列：对要推后执行的工作排队，稍后在进程上下文中执行他们


软中断的实现
	软中断是在编译期间静态分配的
	注册的软中断必须在标记后才会执行，通常，中断处理程序会在返回前标记他的软中断
	软中断在do_softirq()中执行
	
	//软中断结构
	struct softirq_action {
		void (*action)(struct softirq_action *); //待执行的函数
		void *data; //传给函数的参数
	}
	
	//软中断处理程序
	void softirq_handler(struct softirq_action *);





more:
1、软中断实现，位置：kernel/softirq.c